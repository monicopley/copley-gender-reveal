<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Welcome to Our Gender Reveal!</title>
  <style>
    /* Page-wide styling */
    body {
      background-color: #f0f8ff; /* Very light blue, almost white */
      margin: 0;
      padding: 0;
      text-align: center;
      font-family: sans-serif;
    }

    /* Main headings */
    h1 {
      color: teal;             /* Teal header */
      font-size: 3rem;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    h2 {
      color: #555555;         /* Dark gray subheader */
      font-size: 1.5rem;
      margin-bottom: 2rem;
    }

    /* Scratch card container */
    #scratchCardContainer {
      margin: 0 auto;
      position: relative;
      width: 300px;
      height: 300px;
      border: 2px solid #000;  /* Visible border */
    }

    /* Canvas for the underlying content (beige + reveal text) */
    #underCanvas {
      position: relative;
      z-index: 1;
    }

    /* Canvas for the grey overlay with the card number, scratched away by user */
    #overlayCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
      cursor: crosshair;
    }

    /* Countdown text styling */
    .countdown {
      font-size: 4rem;
      color: red;
      display: none;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <!-- Page Titles -->
  <h1>Welcome to Our Gender Reveal!</h1>
  <h2>Scratch the card to reveal the surprise!</h2>

  <!-- Scratch Card Container -->
  <div id="scratchCardContainer">
    <canvas id="underCanvas" width="300" height="300"></canvas>
    <canvas id="overlayCanvas" width="300" height="300"></canvas>
  </div>

  <!-- Countdown Display -->
  <div class="countdown" id="countdown"></div>

  <!-- Trumpet sound (make sure to include trumpet.mp3 in the same folder) -->
  <audio id="trumpetSound" src="trumpet.mp3"></audio>

  <!-- Confetti library -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.4.0/dist/confetti.browser.min.js"></script>

  <script>
    /*
      This script implements a 3-card scratch reveal:
      1) Card #3: grey overlay w/ "3". After 70% scratched, reveals "What am I?" (gold).
      2) Card #2: grey overlay w/ "2". After 70%, reveals "Wait for it..." (gold + ellipses in lightblue).
      3) Card #1: grey overlay w/ "1". After 70%, reveals "I'm a GIRL!" (pink), then confetti + trumpet.
    */

    // The states define each card’s data
    const states = [
      {
        numberText: "3",             // Shown on grey overlay
        revealText: "What am I?",    // Shown after scratch
        revealColor: "gold"
      },
      {
        numberText: "2",
        revealText: "Wait for it",
        ellipsesText: "...",         // in lightblue
        revealColor: "gold",
        ellipsesColor: "lightblue"
      },
      {
        numberText: "1",
        revealText: "I'm a GIRL!",
        revealColor: "pink"
      }
    ];

    // DOM elements
    const underCanvas = document.getElementById("underCanvas");
    const underCtx = underCanvas.getContext("2d");
    const overlayCanvas = document.getElementById("overlayCanvas");
    const overlayCtx = overlayCanvas.getContext("2d");
    const countdownEl = document.getElementById("countdown");
    const trumpetSound = document.getElementById("trumpetSound");

    // Sizing
    const canvasWidth = underCanvas.width;
    const canvasHeight = underCanvas.height;

    // State
    let currentStateIndex = 0; // which card we're on
    let isScratching = false;  // user pressing down?
    let lastX = 0;             // last mouse x
    let lastY = 0;             // last mouse y

    // Initialize first card
    initCard(0);

    // LINE-BASED SCRATCHING with offsetX/offsetY
    overlayCanvas.addEventListener("mousedown", (e) => {
      isScratching = true;
      lastX = e.offsetX;
      lastY = e.offsetY;
      e.preventDefault();
    });
    overlayCanvas.addEventListener("mousemove", (e) => {
      if (!isScratching) return;
      scratchLine(e.offsetX, e.offsetY);
      e.preventDefault();
    });
    overlayCanvas.addEventListener("mouseup", (e) => {
      isScratching = false;
      overlayCtx.globalCompositeOperation = "source-over"; // reset
      checkScratchPercentage();
      e.preventDefault();
    });
    overlayCanvas.addEventListener("mouseleave", () => {
      isScratching = false;
    });

    // (Optional) Touch events
    overlayCanvas.addEventListener("touchstart", (e) => {
      isScratching = true;
      const rect = overlayCanvas.getBoundingClientRect();
      lastX = e.touches[0].clientX - rect.left;
      lastY = e.touches[0].clientY - rect.top;
      e.preventDefault();
    }, { passive: false });
    overlayCanvas.addEventListener("touchmove", (e) => {
      if (!isScratching) return;
      e.preventDefault();
      const rect = overlayCanvas.getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const y = e.touches[0].clientY - rect.top;
      scratchLine(x, y);
    }, { passive: false });
    overlayCanvas.addEventListener("touchend", (e) => {
      isScratching = false;
      overlayCtx.globalCompositeOperation = "source-over";
      checkScratchPercentage();
      e.preventDefault();
    }, { passive: false });

    /**
     * Initialize the card for given state index (0: #3, 1: #2, 2: #1).
     */
    function initCard(stateIndex) {
      currentStateIndex = stateIndex;
      // Clear both canvases
      underCtx.clearRect(0, 0, canvasWidth, canvasHeight);
      overlayCtx.clearRect(0, 0, canvasWidth, canvasHeight);

      drawUnderCanvas(states[stateIndex]);
      drawOverlay(states[stateIndex]);
    }

    /**
     * Under-canvas: Draw beige background + reveal text (in gold, pink, etc).
     */
    function drawUnderCanvas(state) {
      // Fill with matching page color or distinct color for contrast
      underCtx.fillStyle = "#f0f8ff"; 
      underCtx.fillRect(0, 0, canvasWidth, canvasHeight);

      // If the second card, handle special ellipses color
      if (currentStateIndex === 1) {
        // "Wait for it" in gold, "..." in lightblue
        underCtx.textAlign = "center";
        underCtx.textBaseline = "middle";
        underCtx.font = "bold 30px sans-serif";

        // Draw "Wait for it" in gold
        underCtx.fillStyle = state.revealColor;
        const textWithoutEllipses = state.revealText; // "Wait for it"
        const measure = underCtx.measureText(textWithoutEllipses);
        const offsetX = canvasWidth / 2 - 10;
        underCtx.fillText(textWithoutEllipses, offsetX, canvasHeight / 2);

        // Draw ellipses in lightblue, right after the main text
        underCtx.fillStyle = state.ellipsesColor;
        underCtx.fillText(state.ellipsesText, offsetX + measure.width, canvasHeight / 2);

      } else {
        // Card #3 or #1
        underCtx.textAlign = "center";
        underCtx.textBaseline = "middle";
        underCtx.font = "bold 30px sans-serif";
        underCtx.fillStyle = state.revealColor;
        underCtx.fillText(state.revealText, canvasWidth / 2, canvasHeight / 2);
      }
    }

    /**
     * Overlay-canvas: Draw the lightgrey background + big black number (3,2,1).
     */
    function drawOverlay(state) {
      overlayCtx.globalCompositeOperation = "source-over";
      overlayCtx.fillStyle = "lightgrey";  /* The user’s requirement: light grey overlay */
      overlayCtx.fillRect(0, 0, canvasWidth, canvasHeight);

      // Large black number in center
      overlayCtx.textAlign = "center";
      overlayCtx.textBaseline = "middle";
      overlayCtx.font = "bold 100px sans-serif";
      overlayCtx.fillStyle = "black";
      overlayCtx.fillText(state.numberText, canvasWidth / 2, canvasHeight / 2);
    }

    /**
     * Erase a line from (lastX, lastY) to (x, y) using destination-out.
     */
    function scratchLine(x, y) {
      overlayCtx.globalCompositeOperation = "destination-out";
      overlayCtx.lineWidth = 20;  // thickness of the scratch
      overlayCtx.lineCap = "round";

      overlayCtx.beginPath();
      overlayCtx.moveTo(lastX, lastY);
      overlayCtx.lineTo(x, y);
      overlayCtx.stroke();
      overlayCtx.closePath();

      lastX = x;
      lastY = y;
    }

    /**
     * After each scratch, we call this to see if more than 70% has been erased.
     * If so, reveal the text, then do a 3,2,1 countdown. Next card or final confetti.
     */
    function checkScratchPercentage() {
      // Get overlay pixel data
      const imageData = overlayCtx.getImageData(0, 0, canvasWidth, canvasHeight).data;
      let transparentPixels = 0;
      for (let i = 3; i < imageData.length; i += 4) {
        // If alpha is 0, pixel is fully transparent
        if (imageData[i] === 0) {
          transparentPixels++;
        }
      }
      const totalPixels = canvasWidth * canvasHeight;
      const percentErased = (transparentPixels / totalPixels) * 100;

      if (percentErased >= 70) {
        // Clear entire overlay, reveal message
        overlayCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        startCountdownAndNext();
      }
    }

    /**
     * Shows a 3,2,1 countdown, then moves to next card or final confetti+sound.
     */
    function startCountdownAndNext() {
      countdownEl.style.display = "block";
      let counter = 3;
      countdownEl.innerText = counter;

      const intervalId = setInterval(() => {
        counter--;
        countdownEl.innerText = counter;
        if (counter === 0) {
          clearInterval(intervalId);
          countdownEl.style.display = "none";

          // Move to next card or do final celebration
          if (currentStateIndex < states.length - 1) {
            initCard(currentStateIndex + 1);
          } else {
            // Final reveal => confetti & trumpet
            launchConfetti();
            trumpetSound.play();
          }
        }
      }, 1000);
    }

    /**
     * Launch confetti for ~5 seconds across the screen.
     */
    function launchConfetti() {
      const endTime = Date.now() + 5000;
      (function frame() {
        confetti({
          particleCount: 5,
          angle: 60,
          spread: 55,
          origin: { x: 0 }
        });
        confetti({
          particleCount: 5,
          angle: 120,
          spread: 55,
          origin: { x: 1 }
        });
        if (Date.now() < endTime) {
          requestAnimationFrame(frame);
        }
      })();
    }
  </script>
</body>
</html>
